Terminals which are not used

   REGEXP_LITERAL
   ELSE
   ELSIF
   SWITHC
   CASE
   DEFAULT_T
   WHILE
   DO_T
   FOR
   FOREACH
   RETURN_T
   BREAK
   CONTINUE
   NULL_T
   LB
   RB
   SEMICOLON
   COLON
   COMMA
   ASSIGN_T
   LOGICAL_AND
   LOGICAL_OR
   EQ
   NE
   GT
   GE
   LT
   LE
   ADD
   SUB
   MUL
   DIV
   MOD
   BIT_AND
   BIT_OR
   BIT_XOR
   BIT_NOT
   TRUE_T
   FALSE_T
   EXCLAMATION
   DOT_T
   ADD_ASSIGN_T
   SUB_ASSIGN_T
   MUL_ASSIGN_T
   DIV_ASSIGN_T
   MOD_ASSIGN_T
   INCREMENT
   DECREMENT
   TRY
   CATCH
   FINALLY
   THROW
   THROWS
   VOID_T
   BOOLEAN_T
   INT_T
   DOUBLE_T
   STRING_T
   NATIVE_POINTER_T
   NEW
   REQUIRE
   RENAME
   CLASS_T
   INTERFACE_T
   PUBLIC_T
   PRIVATE_T
   VIRTUAL_T
   OVERRIED_T
   ABSTRACT_T
   THIS_T
   SUPER_T
   CONSTRUCTOR
   INSTANCEOF
   DOWN_CAST_BEGIN
   DOWN_CAST_END
   DELEGATE
   FINAL
   ENUM
   CONST


Grammar

    0 $accept: unit $end

    1 unit: IF LP expression RP block

    2 expression: INT_LITERAL
    3           | DOUBLE_LITERAL
    4           | STRING_LITERAL
    5           | IDENTIFER

    6 block: LC RC


Terminals, with rules where they appear

$end (0) 0
error (256)
INT_LITERAL (258) 2
DOUBLE_LITERAL (259) 3
STRING_LITERAL (260) 4
REGEXP_LITERAL (261)
IDENTIFER (262) 5
IF (263) 1
ELSE (264)
ELSIF (265)
SWITHC (266)
CASE (267)
DEFAULT_T (268)
WHILE (269)
DO_T (270)
FOR (271)
FOREACH (272)
RETURN_T (273)
BREAK (274)
CONTINUE (275)
NULL_T (276)
LP (277) 1
RP (278) 1
LC (279) 6
RC (280) 6
LB (281)
RB (282)
SEMICOLON (283)
COLON (284)
COMMA (285)
ASSIGN_T (286)
LOGICAL_AND (287)
LOGICAL_OR (288)
EQ (289)
NE (290)
GT (291)
GE (292)
LT (293)
LE (294)
ADD (295)
SUB (296)
MUL (297)
DIV (298)
MOD (299)
BIT_AND (300)
BIT_OR (301)
BIT_XOR (302)
BIT_NOT (303)
TRUE_T (304)
FALSE_T (305)
EXCLAMATION (306)
DOT_T (307)
ADD_ASSIGN_T (308)
SUB_ASSIGN_T (309)
MUL_ASSIGN_T (310)
DIV_ASSIGN_T (311)
MOD_ASSIGN_T (312)
INCREMENT (313)
DECREMENT (314)
TRY (315)
CATCH (316)
FINALLY (317)
THROW (318)
THROWS (319)
VOID_T (320)
BOOLEAN_T (321)
INT_T (322)
DOUBLE_T (323)
STRING_T (324)
NATIVE_POINTER_T (325)
NEW (326)
REQUIRE (327)
RENAME (328)
CLASS_T (329)
INTERFACE_T (330)
PUBLIC_T (331)
PRIVATE_T (332)
VIRTUAL_T (333)
OVERRIED_T (334)
ABSTRACT_T (335)
THIS_T (336)
SUPER_T (337)
CONSTRUCTOR (338)
INSTANCEOF (339)
DOWN_CAST_BEGIN (340)
DOWN_CAST_END (341)
DELEGATE (342)
FINAL (343)
ENUM (344)
CONST (345)


Nonterminals, with rules where they appear

$accept (91)
    on left: 0
unit (92)
    on left: 1, on right: 0
expression (93)
    on left: 2 3 4 5, on right: 1
block (94)
    on left: 6, on right: 1


state 0

    0 $accept: . unit $end

    IF  shift, and go to state 1

    unit  go to state 2


state 1

    1 unit: IF . LP expression RP block

    LP  shift, and go to state 3


state 2

    0 $accept: unit . $end

    $end  shift, and go to state 4


state 3

    1 unit: IF LP . expression RP block

    INT_LITERAL     shift, and go to state 5
    DOUBLE_LITERAL  shift, and go to state 6
    STRING_LITERAL  shift, and go to state 7
    IDENTIFER       shift, and go to state 8

    expression  go to state 9


state 4

    0 $accept: unit $end .

    $default  accept


state 5

    2 expression: INT_LITERAL .

    $default  reduce using rule 2 (expression)


state 6

    3 expression: DOUBLE_LITERAL .

    $default  reduce using rule 3 (expression)


state 7

    4 expression: STRING_LITERAL .

    $default  reduce using rule 4 (expression)


state 8

    5 expression: IDENTIFER .

    $default  reduce using rule 5 (expression)


state 9

    1 unit: IF LP expression . RP block

    RP  shift, and go to state 10


state 10

    1 unit: IF LP expression RP . block

    LC  shift, and go to state 11

    block  go to state 12


state 11

    6 block: LC . RC

    RC  shift, and go to state 13


state 12

    1 unit: IF LP expression RP block .

    $default  reduce using rule 1 (unit)


state 13

    6 block: LC RC .

    $default  reduce using rule 6 (block)
